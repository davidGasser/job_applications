{% extends "base_fullwidth.html" %}

{% block title %}Kanban Board - {{ super() }}{% endblock %}

{% block head %}
<style>
    .kanban-container {
        padding: 2rem;
        display: flex;
        flex-direction: column;
        height: 100%;
        box-sizing: border-box;
    }

    .kanban-header {
        display: flex;
        justify-content: center;
        align-items: center;
        margin-bottom: 2rem;
        gap: 1.5rem;
        position: relative;
    }

    .kanban-header h1 {
        margin: 0;
    }

    #add-job-button {
        position: absolute;
        right: 0;
    }

    .kanban-board {
        display: flex;
        gap: 1.5rem;
        flex-grow: 1;
        overflow-x: auto;
        overflow-y: auto;
        padding-bottom: 1rem;
        position: relative;
    }

    .kanban-column {
        flex: 0 0 auto;
        min-width: 320px;
        max-width: 400px;
        background-color: var(--background-color);
        border: 1px solid var(--border-color);
        border-radius: 12px;
        display: flex;
        flex-direction: column;
        overflow: visible;
        align-self: flex-start;
    }

    /* Interviewing column with horizontal sub-columns */
    .kanban-interviewing-wrapper {
        flex: 0 0 auto;
        min-width: 320px;
        max-width: none;
        overflow: visible;
    }

    .kanban-interviewing-wrapper .kanban-column-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
    }

    .btn-add-step {
        padding: 0.4rem 0.85rem;
        font-size: 0.85rem;
        background-color: var(--background-color);
        color: var(--text-secondary);
        border: 1px solid var(--border-color);
        margin-left: auto;
    }

    .btn-add-step:hover {
        background-color: var(--primary-light);
        color: var(--primary-color);
        border-color: var(--primary-color);
    }

    .interviewing-steps {
        display: flex;
        gap: 1.5rem;
        padding: 1rem 1.5rem;
        justify-content: flex-start;
        overflow: visible;
    }

    .interviewing-steps.single-step {
        justify-content: center;
    }

    .interview-step-column {
        flex: 0 0 320px;
        width: 320px;
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
        overflow: visible;
    }

    .interview-step-column .kanban-cards {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
        overflow: visible;
    }


    .interview-step-header {
        padding: 0;
        margin-bottom: 0.5rem;
    }

    .interview-step-header h3 {
        margin: 0;
        font-size: 0.85rem;
        font-weight: 600;
        color: var(--text-secondary);
        text-transform: uppercase;
        letter-spacing: 0.5px;
        padding-bottom: 0.5rem;
        border-bottom: 2px solid var(--border-color);
    }

    /* Interview step drop zones */
    .interview-drop-zone {
        flex: 0 0 60px;
        display: flex;
        align-items: center;
        justify-content: center;
        border: 2px dashed var(--border-color);
        border-radius: 8px;
        transition: all 0.2s;
        color: var(--text-secondary);
        font-size: 1rem;
        font-weight: 600;
        opacity: 0.4;
        background-color: var(--background-color);
        padding: 1rem;
        text-align: center;
        min-height: 200px;
    }

    .interview-drop-zone.drag-over {
        border-color: var(--primary-color);
        background-color: var(--primary-light);
        opacity: 1;
        transform: scale(1.02);
    }

    .interview-drop-zone-left::before {
        content: '‚Üê';
    }

    .interview-drop-zone-right::before {
        content: '‚Üí';
    }

    .interview-drop-zone[data-drop-action="between"]::before {
        content: '+';
        font-size: 1.5rem;
    }

    .kanban-column-header {
        padding: 1.25rem 1.5rem;
        border-bottom: 2px solid var(--border-color);
        flex-shrink: 0;
        background-color: var(--card-background);
        border-radius: 12px 12px 0 0;
    }

    .kanban-column-header h2 {
        margin: 0;
        font-size: 1.1rem;
        font-weight: 600;
        color: var(--text-color);
        display: flex;
        align-items: center;
        gap: 0.5rem;
    }

    .job-count {
        background-color: var(--primary-light);
        color: var(--primary-color);
        padding: 0.25rem 0.6rem;
        border-radius: 12px;
        font-size: 0.8rem;
        font-weight: 600;
    }

    .kanban-cards {
        display: flex;
        flex-direction: column;
        gap: 1rem;
        padding: 1rem;
        overflow: visible;
    }

    .kanban-card {
        background-color: var(--card-background);
        border: 1px solid var(--border-color);
        border-radius: 10px;
        padding: 1.25rem;
        cursor: grab;
        transition: all 0.2s;
        box-shadow: var(--shadow-sm);
    }

    .kanban-card:hover {
        box-shadow: var(--shadow-md);
        border-color: var(--primary-color);
        transform: translateY(-2px);
    }

    .kanban-card:active {
        cursor: grabbing;
    }

    .kanban-card.dragging {
        opacity: 0.5;
        transform: rotate(2deg);
    }

    .kanban-card h3 {
        margin: 0 0 0.5rem 0;
        font-size: 1rem;
        font-weight: 600;
        color: var(--text-color);
        line-height: 1.3;
    }

    .kanban-card p {
        margin: 0;
        font-size: 0.875rem;
        color: var(--text-secondary);
    }

    /* Modal Styling */
    #job-details-modal .modal-content {
        width: 80%;
        max-width: none;
        height: 98vh;
        margin: 1vh auto;
        overflow: hidden;
        display: flex;
        flex-direction: column;
        border: 4px solid var(--border-color);
        transition: border-color 0.3s ease;
    }

    #job-details-modal .modal-body-wrapper {
        overflow-y: auto;
        flex: 1;
        padding: 0 1.5rem;
    }

    .modal-header {
        display: flex;
        align-items: center;
        gap: 0.75rem;
        padding: 0 1.5rem 0.35rem 1.5rem;
        margin-top: 0 !important;
        border-top-left-radius: 8px;
        border-top-right-radius: 8px;
        flex-shrink: 0;
    }

    .modal-header-content {
        flex: 1;
        display: flex;
        flex-direction: column;
        gap: 0.25rem;
        margin-bottom: 0 !important;
    }

    .modal-header-content * {
        margin-bottom: 0 !important;
    }

    .modal-header h2 {
        margin: 0 !important;
        font-size: 1.5rem;
        line-height: 1.3;
    }

    #job-details-modal .modal-header {
        padding-bottom: 0 !important;
        margin-bottom: 0 !important;
    }

    .modal-subheader {
        display: flex;
        align-items: center;
        gap: 0.75rem;
        flex-wrap: wrap;
        font-size: 0.95rem;
        color: var(--text-secondary);
    }

    .modal-subheader-item {
        display: flex;
        align-items: center;
        gap: 0.35rem;
    }

    .modal-subheader-divider {
        color: var(--border-color);
    }

    .modal-actions {
        padding: 1rem 1.5rem 0 1.5rem;
        margin-bottom: 0 !important;
        flex-shrink: 0;
    }

    .modal-section {
        margin-bottom: 1.25rem;
    }

    .modal-section h3 {
        font-size: 1rem;
        font-weight: 600;
        margin: 0 0 0.75rem 0;
        color: var(--text-color);
        display: flex;
        align-items: center;
        gap: 0.5rem;
    }

    .btn-inline {
        background: none;
        border: 1px solid var(--border-color);
        color: var(--primary-color);
        padding: 0.15rem 0.5rem;
        font-size: 0.85rem;
        border-radius: 4px;
        cursor: pointer;
        transition: all 0.2s;
    }

    .btn-inline:hover {
        background-color: var(--primary-color);
        color: white;
        border-color: var(--primary-color);
    }

    .job-description-box {
        background-color: var(--background-color);
        padding: 1.5rem;
        border-radius: 8px;
        font-size: 0.9rem;
        line-height: 1.7;
        color: var(--text-color);
        word-wrap: break-word;
    }

    /* Markdown styling */
    .job-description-box h1,
    .job-description-box h2,
    .job-description-box h3,
    .job-description-box h4 {
        margin-top: 1.5em;
        margin-bottom: 0.5em;
        font-weight: 600;
        line-height: 1.3;
    }

    .job-description-box h2 {
        font-size: 1.3rem;
        border-bottom: 1px solid var(--border-color);
        padding-bottom: 0.3em;
    }

    .job-description-box h3 {
        font-size: 1.1rem;
    }

    .job-description-box p {
        margin: 0.8em 0;
    }

    .job-description-box ul,
    .job-description-box ol {
        margin: 0.8em 0;
        padding-left: 2em;
    }

    .job-description-box li {
        margin: 0.4em 0;
    }

    .job-description-box strong {
        font-weight: 600;
        color: var(--text-color);
    }

    .job-description-box em {
        font-style: italic;
    }

    .job-description-box code {
        background-color: #f3f4f6;
        padding: 0.2em 0.4em;
        border-radius: 3px;
        font-family: monospace;
        font-size: 0.85em;
    }

    .info-row {
        display: flex;
        align-items: center;
        gap: 0.75rem;
        margin-bottom: 0.75rem;
    }

    .info-label {
        font-weight: 600;
        color: var(--text-secondary);
        min-width: 120px;
        font-size: 0.875rem;
    }

    .info-value {
        flex: 1;
        font-size: 0.9rem;
    }

    .info-value input {
        width: 100%;
    }

    .contact-list, .date-list {
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
    }

    .contact-item, .date-item {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 0.5rem;
        padding: 0.35rem 0.5rem;
        background-color: var(--background-color);
        border-radius: 4px;
        font-size: 0.8rem;
    }

    .contact-item-content, .date-item-content {
        flex: 1;
        min-width: 0;
        color: var(--text-color);
    }

    .contact-item-content strong, .date-item-content strong {
        font-weight: 600;
        margin-right: 0.35rem;
    }

    .contact-item-content span, .date-item-content span {
        color: var(--text-secondary);
    }

    .item-actions {
        flex-shrink: 0;
    }

    .delete-contact, .delete-date {
        padding: 0.1rem 0.35rem !important;
        font-size: 0.75rem !important;
        line-height: 1;
        min-width: auto !important;
        background-color: transparent !important;
        border: 1px solid var(--border-color) !important;
        color: var(--text-secondary) !important;
        border-radius: 3px;
    }

    .delete-contact:hover, .delete-date:hover {
        background-color: #ef4444 !important;
        border-color: #ef4444 !important;
        color: white !important;
    }

    .add-item-form {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 0.75rem;
        padding: 1rem;
        background-color: var(--background-color);
        border-radius: 8px;
        border: 1px solid var(--border-color);
        margin-top: 0.75rem;
    }

    .add-item-form.full-width {
        grid-template-columns: 1fr;
    }

    .add-item-form input,
    .add-item-form select,
    .add-item-form textarea {
        width: 100%;
    }

    .add-item-form .full-width-field {
        grid-column: 1 / -1;
    }

    #job-details-modal .modal-actions {
        display: flex;
        gap: 0.75rem;
        border-top: 1px solid var(--border-color);
    }

    .modal-actions button, .modal-actions a {
        flex: 1;
        padding: 0.5rem 1rem;
        font-size: 0.9rem;
        margin-bottom: 0 !important;
    }

    .status-badge {
        display: inline-block;
        padding: 0.35rem 0.75rem;
        border-radius: 20px;
        font-size: 0.8rem;
        font-weight: 600;
    }

    .status-new { background-color: #dbeafe; color: #1e40af; }
    .status-interested { background-color: #fef3c7; color: #92400e; }
    .status-applied { background-color: #ddd6fe; color: #5b21b6; }
    .status-interviewing { background-color: #d1fae5; color: #065f46; }
    .status-offer { background-color: #bbf7d0; color: #14532d; }
    .status-rejected { background-color: #f3f4f6; color: #4b5563; }

    .empty-column {
        text-align: center;
        padding: 2rem 1rem;
        color: var(--text-secondary);
        font-size: 0.875rem;
    }

    textarea {
        min-height: 100px;
        resize: vertical;
    }

    #modal-job-notes {
        min-height: 80px;
        max-height: 300px;
        overflow-y: auto;
        resize: vertical;
    }

    .nav-job-button {
        background: none;
        border: 2px solid var(--border-color);
        color: var(--text-color);
        font-size: 2rem;
        width: 40px;
        height: 40px;
        border-radius: 50%;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s;
        padding: 0;
        line-height: 1;
    }

    .nav-job-button:hover:not(:disabled) {
        background-color: var(--primary-color);
        border-color: var(--primary-color);
        color: white;
        transform: scale(1.1);
    }

    .nav-job-button:disabled {
        opacity: 0.3;
        cursor: not-allowed;
    }

    .modal-nav-bar {
        padding: 0.5rem 1.5rem;
        margin: 1.2rem 0;
        background-color: var(--background-color);
        border-bottom: 1px solid var(--border-color);
        font-size: 0.75rem;
        color: var(--text-secondary);
        display: flex;
        justify-content: space-between;
        align-items: center;
        flex-shrink: 0;
    }

    .modal-nav-shortcuts {
        display: flex;
        gap: 1.5rem;
        flex-wrap: wrap;
    }

    .modal-nav-shortcut {
        display: flex;
        align-items: center;
        gap: 0.35rem;
    }

    .modal-nav-key {
        background-color: white;
        border: 1px solid var(--border-color);
        border-radius: 4px;
        padding: 0.15rem 0.4rem;
        font-family: monospace;
        font-size: 0.75rem;
        font-weight: 600;
    }

    /* Search bar */
    .search-container {
        width: 100%;
        max-width: 500px;
    }

    .search-input {
        width: 100%;
        padding: 0.75rem 1rem;
        font-size: 0.95rem;
        border: 1px solid var(--border-color);
        border-radius: 8px;
        background-color: white;
        transition: all 0.2s;
    }

    .search-input:focus {
        outline: none;
        border-color: var(--primary-color);
        box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1);
    }

    .search-input::placeholder {
        color: var(--text-secondary);
    }

    /* Hide cards that don't match search */
    .kanban-card.hidden-by-search {
        display: none;
    }

    /* Interview Chain Visualization */
    .interview-type-palette {
        display: flex;
        gap: 0.75rem;
        flex-wrap: wrap;
        margin-bottom: 2rem;
        padding: 1rem;
        background-color: var(--background-color);
        border-radius: 8px;
        border: 1px solid var(--border-color);
        align-items: center;
        justify-content: center;
    }

    .interview-type-block {
        padding: 0.6rem 1rem;
        background-color: white;
        border: 2px solid var(--primary-color);
        border-radius: 6px;
        cursor: grab;
        font-size: 0.85rem;
        font-weight: 600;
        color: var(--primary-color);
        transition: all 0.2s;
        user-select: none;
    }

    .interview-type-block:hover {
        background-color: var(--primary-light);
        transform: translateY(-2px);
        box-shadow: 0 4px 6px rgba(0,0,0,0.1);
    }

    .interview-type-block:active {
        cursor: grabbing;
    }

    .interview-type-block.custom {
        border-color: var(--text-secondary);
        color: var(--text-secondary);
    }

    .btn-add-custom-type {
        padding: 0.6rem 1rem;
        background-color: transparent;
        border: 2px dashed var(--border-color);
        border-radius: 6px;
        cursor: pointer;
        font-size: 0.85rem;
        font-weight: 600;
        color: var(--text-secondary);
        transition: all 0.2s;
    }

    .btn-add-custom-type:hover {
        border-color: var(--primary-color);
        color: var(--primary-color);
        background-color: var(--primary-light);
    }

    .interview-chain-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 1.5rem;
        padding: 0.5rem 1rem;
        min-height: 150px;
    }

    .interview-chain {
        display: flex;
        align-items: center;
        gap: 0;
        position: relative;
        padding: 0 2rem;
    }

    .interview-chain-link {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 0.5rem;
        position: relative;
        margin: 0 0.75rem;
    }

    .chain-link-circle {
        width: 60px;
        height: 60px;
        border-radius: 50%;
        background-color: #e5e7eb;
        border: 3px solid #9ca3af;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: 700;
        font-size: 1.5rem;
        color: #6b7280;
        position: relative;
        z-index: 2;
        transition: all 0.3s;
        line-height: 1;
    }

    .chain-link-circle.filled {
        background-color: var(--primary-color);
        border-color: var(--primary-color);
        color: white;
        font-size: 1.8rem;
    }

    .chain-link-circle.completed {
        background-color: #10b981;
        border-color: #10b981;
        color: white;
    }

    .chain-link-circle.drag-over {
        background-color: var(--primary-light);
        border-color: var(--primary-color);
        transform: scale(1.1);
        box-shadow: 0 0 0 4px rgba(79, 70, 229, 0.2);
    }

    .chain-link-connector {
        width: 70px;
        height: 4px;
        background-color: #e5e7eb;
        position: relative;
        z-index: 1;
        margin: 0 -5px;
    }

    .chain-link-connector.filled {
        background-color: var(--primary-color);
    }

    .chain-link-connector.completed {
        background-color: #10b981;
    }

    .chain-link-details {
        position: absolute;
        top: 75px;
        min-width: 140px;
        background-color: transparent;
        padding: 0.5rem;
        font-size: 0.75rem;
        text-align: center;
    }

    .chain-link-type {
        font-weight: 600;
        color: var(--text-color);
        margin-bottom: 0.25rem;
        font-size: 0.9rem;
    }

    .chain-link-date {
        color: var(--text-secondary);
        font-size: 0.8rem;
    }

    .chain-link-delete {
        position: absolute;
        top: -7px;
        left: -7px;
        width: 22px;
        height: 22px;
        border-radius: 50%;
        background-color: #ef4444;
        color: white;
        border: 2px solid white;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        font-size: 0.75rem;
        font-weight: bold;
        transition: all 0.2s;
        z-index: 10;
        box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        pointer-events: auto;
        line-height: 1;
    }

    .chain-link-delete:hover {
        background-color: #dc2626;
        transform: scale(1.15);
    }

    .chain-link-complete {
        position: absolute;
        top: -7px;
        right: -7px;
        width: 22px;
        height: 22px;
        border-radius: 50%;
        background-color: #10b981;
        color: white;
        border: 2px solid white;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        font-size: 0.7rem;
        font-weight: bold;
        transition: all 0.2s;
        z-index: 10;
        box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        pointer-events: auto;
        line-height: 1;
    }

    .chain-link-complete:hover {
        background-color: #059669;
        transform: scale(1.15);
    }

    .chain-link-add-date {
        position: absolute;
        bottom: -16px;
        left: 50%;
        transform: translateX(-50%);
        width: 26px;
        height: 26px;
        border-radius: 50%;
        background-color: var(--primary-color);
        color: white;
        border: 2px solid white;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        font-size: 0.75rem;
        font-weight: bold;
        transition: all 0.2s;
        z-index: 10;
        box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        pointer-events: auto;
        line-height: 1;
    }

    .chain-link-add-date:hover {
        background-color: #4f46e5;
        transform: translateX(-50%) scale(1.15);
    }

    .chain-empty-state {
        text-align: center;
        color: var(--text-secondary);
        font-size: 0.9rem;
        padding: 2rem;
    }

    .chain-empty-state p {
        margin-bottom: 0.5rem;
    }

    /* New job highlight animation */
    @keyframes pulseHighlight {
        0% {
            transform: scale(1);
            box-shadow: 0 0 0 0 rgba(79, 70, 229, 0.7);
        }
        50% {
            transform: scale(1.05);
            box-shadow: 0 0 0 10px rgba(79, 70, 229, 0);
        }
        100% {
            transform: scale(1);
            box-shadow: 0 0 0 0 rgba(79, 70, 229, 0);
        }
    }

    .kanban-card.new-job-highlight {
        animation: pulseHighlight 1s ease-out 1;
        border-color: var(--primary-color);
        background-color: var(--primary-light);
    }

    /* Auto-scroll zones */
    .scroll-zone {
        position: fixed;
        pointer-events: none;
        z-index: 10;
        opacity: 0;
        transition: opacity 0.3s;
    }

    .scroll-zone-left,
    .scroll-zone-right {
        top: 0;
        bottom: 0;
        width: 250px;
    }

    .scroll-zone-top,
    .scroll-zone-bottom {
        left: 0;
        right: 0;
        height: 200px;
    }

    .scroll-zone-left {
        left: 0;
        background: linear-gradient(to right, rgba(59, 130, 246, 0.15), transparent);
    }

    .scroll-zone-right {
        right: 0;
        background: linear-gradient(to left, rgba(59, 130, 246, 0.15), transparent);
    }

    .scroll-zone-top {
        top: auto;
        background: linear-gradient(to bottom, rgba(59, 130, 246, 0.15), transparent);
    }

    .scroll-zone-bottom {
        bottom: 0;
        top: auto;
        background: linear-gradient(to top, rgba(59, 130, 246, 0.15), transparent);
    }

    .scroll-zone.active {
        opacity: 1;
    }

    /* Auto-scroll tip indicator */
    .auto-scroll-tip {
        position: absolute;
        left: 0;
        top: 0;
        background: rgba(0, 0, 0, 0.85);
        color: white;
        padding: 0.5rem 1rem;
        border-radius: 6px;
        font-size: 0.85rem;
        z-index: 100;
        display: flex;
        align-items: center;
        gap: 0.5rem;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        transition: opacity 0.3s;
    }

    .auto-scroll-tip.disabled {
        background: rgba(239, 68, 68, 0.9);
    }

    .auto-scroll-tip kbd {
        background: rgba(255, 255, 255, 0.2);
        padding: 0.15rem 0.4rem;
        border-radius: 3px;
        font-family: monospace;
        font-size: 0.8rem;
    }
</style>
{% endblock %}

{% block content %}
<div class="kanban-container">
    <!-- Auto-scroll zones -->
    <div class="scroll-zone scroll-zone-left" id="scroll-zone-left"></div>
    <div class="scroll-zone scroll-zone-right" id="scroll-zone-right"></div>
    <div class="scroll-zone scroll-zone-top" id="scroll-zone-top"></div>
    <div class="scroll-zone scroll-zone-bottom" id="scroll-zone-bottom"></div>

    <div class="kanban-header">
        <!-- Auto-scroll tip -->
        <div class="auto-scroll-tip" id="auto-scroll-tip">
            <span>Auto-scroll enabled</span>
            <kbd>Space</kbd>
            <span>to toggle</span>
        </div>

        <div class="search-container">
            <input type="text"
                   id="job-search"
                   class="search-input"
                   placeholder="Search jobs by title or company...">
        </div>
        <button id="add-job-button">+ Add Job</button>
    </div>

    <div class="kanban-board">
        {% for status in statuses %}
            {% if status == 'Interviewing' %}
                <!-- Special layout for Interviewing status with sub-columns -->
                <div class="kanban-column kanban-interviewing-wrapper" data-status="{{ status }}">
                    <div class="kanban-column-header">
                        <h2>
                            {{ status }}
                            <span class="job-count">{{ jobs | selectattr('status', 'equalto', status) | list | length }}</span>
                        </h2>
                        <button type="button" class="btn-add-step" id="add-interview-step-button">+ Step</button>
                    </div>
                    <div class="interviewing-steps">
                        {% if interview_steps %}
                            {% for step in interview_steps %}
                                <!-- Left drop zone (only show before first step if it's > 1, or between steps with gaps) -->
                                {% if loop.first and step > 1 %}
                                <div class="interview-drop-zone interview-drop-zone-left" data-drop-action="before" data-step="{{ step }}"></div>
                                {% elif not loop.first and step - interview_steps[loop.index0 - 1] > 1 %}
                                <div class="interview-drop-zone" data-drop-action="between" data-left-step="{{ interview_steps[loop.index0 - 1] }}" data-right-step="{{ step }}"></div>
                                {% endif %}

                                <div class="interview-step-column" data-interview-step="{{ step }}">
                                    <div class="interview-step-header">
                                        <h3>Step {{ step }}</h3>
                                    </div>
                                    <div class="kanban-cards">
                                        {% set step_jobs = jobs | selectattr('status', 'equalto', status) | selectattr('interview_step', 'equalto', step) | list %}
                                        {% for job in step_jobs %}
                                        <div class="kanban-card" draggable="true" data-job-id="{{ job.id }}" data-interview-step="{{ job.interview_step }}">
                                            <h3>{{ job.title }}</h3>
                                            <p style="font-weight: 600;">{{ job.company }}</p>
                                            {% if job.interview_stage_name %}
                                            <p style="font-size: 0.85rem; color: var(--primary-color); margin-top: 0.25rem; font-weight: 500;">{{ job.interview_stage_name }}</p>
                                            {% endif %}
                                            {% if job.location %}
                                            <p style="font-size: 0.85rem; color: var(--text-secondary); margin-top: 0.25rem;">{{ job.location }}</p>
                                            {% endif %}
                                        </div>
                                        {% endfor %}
                                    </div>
                                </div>

                                <!-- Right drop zone after last step -->
                                {% if loop.last %}
                                <div class="interview-drop-zone interview-drop-zone-right" data-drop-action="after" data-step="{{ step }}"></div>
                                {% endif %}
                            {% endfor %}
                        {% else %}
                            <!-- No interview steps yet - show drop zone -->
                            <div class="interview-drop-zone" data-drop-action="first" style="flex: 1;">
                                Drop here to start interviewing
                            </div>
                        {% endif %}
                    </div>
                </div>
            {% else %}
                <!-- Regular column for other statuses -->
                <div class="kanban-column" data-status="{{ status }}">
                    <div class="kanban-column-header">
                        <h2>
                            {{ status }}
                            <span class="job-count">{{ jobs | selectattr('status', 'equalto', status) | list | length }}</span>
                        </h2>
                    </div>
                    <div class="kanban-cards">
                        {% set column_jobs = jobs | selectattr('status', 'equalto', status) | list %}
                        {% if column_jobs %}
                            {% for job in column_jobs %}
                            <div class="kanban-card" draggable="true" data-job-id="{{ job.id }}">
                                <h3>{{ job.title }}</h3>
                                <p style="font-weight: 600;">{{ job.company }}</p>
                                {% if job.interview_stage_name %}
                                <p style="font-size: 0.85rem; color: var(--primary-color); margin-top: 0.25rem; font-weight: 500;">{{ job.interview_stage_name }}</p>
                                {% endif %}
                                {% if job.location %}
                                <p style="font-size: 0.85rem; color: var(--text-secondary); margin-top: 0.25rem;">{{ job.location }}</p>
                                {% endif %}
                            </div>
                            {% endfor %}
                        {% else %}
                            <div class="empty-column">No jobs in this stage</div>
                        {% endif %}
                    </div>
                </div>
            {% endif %}
        {% endfor %}
    </div>
</div>

<!-- Job Details Modal -->
<div id="job-details-modal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <button id="prev-job-button" class="nav-job-button" type="button">‚Äπ</button>
            <div class="modal-header-content">
                <h2 id="modal-job-title"></h2>
                <div class="modal-subheader">
                    <span class="modal-subheader-item">
                        <strong id="modal-job-company"></strong>
                    </span>
                    <span class="modal-subheader-divider">‚Ä¢</span>
                    <span class="modal-subheader-item" id="modal-job-location"></span>
                    <span class="modal-subheader-divider">‚Ä¢</span>
                    <span class="modal-subheader-item" id="modal-job-status"></span>
                </div>
                <div class="modal-subheader" style="font-size: 0.85rem; margin-top: 0.15rem; margin-bottom: 0;">
                    <span class="modal-subheader-item">
                        Scraped: <span id="modal-job-scraped"></span>
                    </span>
                    <span class="modal-subheader-divider">‚Ä¢</span>
                    <span class="modal-subheader-item">
                        Last updated: <span id="modal-job-updated"></span>
                    </span>
                </div>
            </div>
            <button id="next-job-button" class="nav-job-button" type="button">‚Ä∫</button>
            <button class="close-button" type="button">&times;</button>
        </div>

        <div class="modal-nav-bar">
            <div class="modal-nav-shortcuts">
                <div class="modal-nav-shortcut">
                    <span class="modal-nav-key">‚Üê</span>
                    <span class="modal-nav-key">‚Üí</span>
                    <span>Navigate jobs</span>
                </div>
                <div class="modal-nav-shortcut">
                    <span class="modal-nav-key">‚Üë</span>
                    <span class="modal-nav-key">‚Üì</span>
                    <span>Scroll</span>
                </div>
                <div class="modal-nav-shortcut">
                    <span class="modal-nav-key">Space</span>
                    <span>Apply</span>
                </div>
                <div class="modal-nav-shortcut">
                    <span class="modal-nav-key">Del</span>
                    <span>Delete</span>
                </div>
                <div class="modal-nav-shortcut">
                    <span class="modal-nav-key">Esc</span>
                    <span>Close</span>
                </div>
            </div>
            <div>
                <span id="modal-job-position">Job 1 of 10</span>
            </div>
        </div>

        <div class="modal-body-wrapper">
            <div class="modal-section">
                <h3>Job Description</h3>
                <div class="job-description-box" id="modal-job-description"></div>
            </div>

        <div class="modal-section" id="interview-section" style="display: none;">
            <h3>Interview Pipeline</h3>

            <!-- Interview Type Palette -->
            <div class="interview-type-palette">
                <div class="interview-type-block" draggable="true" data-type="Introduction">üëã Introduction</div>
                <div class="interview-type-block" draggable="true" data-type="Call">‚òéÔ∏è Call</div>
                <div class="interview-type-block" draggable="true" data-type="Technical Interview">üíª Technical</div>
                <div class="interview-type-block" draggable="true" data-type="Coding Challenge">‚å®Ô∏è Coding</div>
                <div class="interview-type-block" draggable="true" data-type="System Design">üèóÔ∏è System Design</div>
                <div class="interview-type-block" draggable="true" data-type="Team Interview">üë®‚Äçüë©‚Äçüë¶ Team</div>
                <div class="interview-type-block" draggable="true" data-type="Manager Interview">üëî Manager</div>
                <div class="interview-type-block" draggable="true" data-type="Culture Fit">ü§ù Culture Fit</div>
                <div class="interview-type-block" draggable="true" data-type="Final Round">üéØ Final</div>
                <button type="button" class="btn-add-custom-type" id="add-custom-interview-type">+ Custom</button>
            </div>

            <!-- Interview Chain -->
            <div class="interview-chain-container" id="interview-chain-container">
                <!-- Chain will be dynamically generated based on interview_step -->
            </div>
        </div>

        <div class="modal-section">
            <h3>Notes
                <span id="notes-save-status" style="font-size: 0.75rem; color: #10b981; font-weight: normal;"></span>
                <button type="button" id="toggle-notes-preview" class="btn-inline" style="margin-left: 0.5rem;">Preview</button>
            </h3>
            <textarea id="modal-job-notes" placeholder="Add notes about this job (supports markdown)..."></textarea>
            <div id="modal-job-notes-preview" class="job-description-box" style="display: none;"></div>
        </div>

        <div class="modal-section">
            <h3>Contacts <button type="button" id="show-contact-form-button" class="btn-inline">+</button></h3>
            <div id="contact-list" class="contact-list"></div>
            <div class="add-item-form" id="contact-form" style="display: none;">
                <input type="text" id="new-contact-name" placeholder="Name">
                <input type="text" id="new-contact-value" placeholder="Email, Phone, or LinkedIn URL" class="full-width-field">
                <button type="button" id="add-contact-button" class="full-width-field">Add</button>
            </div>
        </div>

        <div class="modal-section">
            <h3>Dates <button type="button" id="show-date-form-button" class="btn-inline">+</button></h3>
            <div id="dates-list" class="date-list"></div>
            <div class="add-item-form full-width" id="date-form" style="display: none;">
                <select id="new-date-category" style="grid-column: 1;">
                    <option value="deadline">Deadline</option>
                    <option value="interview">Interview</option>
                    <option value="followup">Follow-up</option>
                    <option value="other">Other</option>
                </select>
                <input type="datetime-local" id="new-date-input" style="grid-column: 2;">
                <button type="button" id="add-date-button" class="full-width-field">Add</button>
            </div>
        </div>
        </div>

        <div class="modal-actions">
            <button type="button" class="btn-secondary" id="close-modal-button">Close</button>
            <button type="button" class="btn-danger" id="delete-job-button">Delete Job</button>
            <a href="#" id="modal-apply-button" class="btn" target="_blank">Apply Now ‚Üí</a>
        </div>
    </div>
</div>

<!-- Add Job Modal -->
<div id="add-job-modal" class="modal">
    <div class="modal-content" style="max-height: 90vh; overflow: hidden; border-radius: 12px; display: flex; flex-direction: column;">
        <div class="modal-header" style="flex-shrink: 0; padding: 2rem 2rem 1rem 2rem; margin-bottom: 0;">
            <h2>Add New Job</h2>
            <button class="close-button" type="button">&times;</button>
        </div>
        <div style="overflow-y: auto; flex: 1; padding: 0 2rem 2rem 2rem;">
        <form id="add-job-form" style="padding: 0;">
            <div class="form-group">
                <label for="linkedin-url">LinkedIn Job URL (Optional)</label>
                <div style="display: flex; gap: 0.5rem;">
                    <input type="url" id="linkedin-url" placeholder="https://www.linkedin.com/jobs/view/..." style="flex: 1;">
                    <button type="button" id="extract-url-button" style="white-space: nowrap;">Extract Info</button>
                </div>
                <span id="extract-status" style="font-size: 0.85rem; color: var(--text-secondary); margin-top: 0.25rem; display: block;"></span>
            </div>
            <div class="form-group">
                <label for="new-job-title">Job Title *</label>
                <input type="text" id="new-job-title" placeholder="e.g., Senior Software Engineer" required>
            </div>
            <div class="form-group">
                <label for="new-job-company">Company *</label>
                <input type="text" id="new-job-company" placeholder="e.g., Tech Corp" required>
            </div>
            <div class="form-group">
                <label for="new-job-location">Location</label>
                <input type="text" id="new-job-location" placeholder="e.g., San Francisco, CA">
            </div>
            <div class="form-group">
                <label for="new-job-description">Job Description</label>
                <textarea id="new-job-description" placeholder="Paste the job description here..." style="min-height: 150px;"></textarea>
            </div>
            <div class="form-group">
                <label for="new-job-link">Application Link</label>
                <input type="url" id="new-job-link" placeholder="https://...">
            </div>
            <div class="form-group">
                <label for="new-job-notes">Notes</label>
                <textarea id="new-job-notes" placeholder="Any initial notes about this job..." style="min-height: 80px;"></textarea>
            </div>
            <div class="modal-actions" style="margin-top: 1rem; padding-top: 1rem;">
                <button type="button" class="btn-secondary" id="cancel-add-job-button">Cancel</button>
                <button type="submit">Create Job</button>
            </div>
        </form>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
document.addEventListener('DOMContentLoaded', () => {
    // Configure marked for safe HTML rendering
    marked.setOptions({
        breaks: true,
        gfm: true,
        headerIds: false,
        mangle: false
    });

    // Helper function to safely render markdown
    function renderMarkdown(text) {
        if (!text || text === 'No description available') return text;
        return marked.parse(text);
    }

    let currentJobId = null;
    let currentJobStep = null;
    let editingDateId = null;
    let allJobs = [];
    let currentJobIndex = -1;
    let notesAutoSaveTimeout = null;

    const detailsModal = document.getElementById('job-details-modal');
    const addJobModal = document.getElementById('add-job-modal');
    const addJobButton = document.getElementById('add-job-button');
    const addJobForm = document.getElementById('add-job-form');

    // Add Job Modal
    addJobButton.addEventListener('click', () => {
        // Clear LinkedIn URL and status when opening modal
        document.getElementById('linkedin-url').value = '';
        document.getElementById('extract-status').textContent = '';
        addJobModal.style.display = 'block';
    });

    // Extract job info from LinkedIn URL
    document.getElementById('extract-url-button').addEventListener('click', async () => {
        const urlInput = document.getElementById('linkedin-url');
        const url = urlInput.value.trim();
        const statusSpan = document.getElementById('extract-status');
        const extractButton = document.getElementById('extract-url-button');

        if (!url) {
            statusSpan.textContent = 'Please enter a LinkedIn URL';
            statusSpan.style.color = '#ef4444';
            return;
        }

        if (!url.includes('linkedin.com/jobs')) {
            statusSpan.textContent = 'Invalid LinkedIn job URL';
            statusSpan.style.color = '#ef4444';
            return;
        }

        // Disable button and show loading
        extractButton.disabled = true;
        extractButton.textContent = 'Extracting...';
        statusSpan.textContent = 'Extracting job information...';
        statusSpan.style.color = '#f59e0b';

        try {
            const response = await fetch('/extract_job_info', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ url: url })
            });

            const result = await response.json();

            if (result.status === 'success') {
                const data = result.data;

                // Populate form fields
                document.getElementById('new-job-title').value = data.title || '';
                document.getElementById('new-job-company').value = data.company || '';
                document.getElementById('new-job-location').value = data.location || '';
                document.getElementById('new-job-description').value = data.description || '';
                document.getElementById('new-job-link').value = data.application_link || url;

                statusSpan.textContent = '‚úì Job information extracted successfully!';
                statusSpan.style.color = '#10b981';
            } else {
                statusSpan.textContent = 'Error: ' + result.message;
                statusSpan.style.color = '#ef4444';
            }
        } catch (error) {
            statusSpan.textContent = 'Error extracting job info: ' + error.message;
            statusSpan.style.color = '#ef4444';
        } finally {
            extractButton.disabled = false;
            extractButton.textContent = 'Extract Info';
        }
    });

    addJobForm.addEventListener('submit', (e) => {
        e.preventDefault();
        const title = document.getElementById('new-job-title').value;
        const company = document.getElementById('new-job-company').value;
        const location = document.getElementById('new-job-location').value;
        const description = document.getElementById('new-job-description').value;
        const application_link = document.getElementById('new-job-link').value;
        const notes = document.getElementById('new-job-notes').value;

        fetch('/job', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                title,
                company,
                location,
                description,
                application_link,
                notes,
                status: 'Interested',
                shortlisted: true
            })
        })
        .then(response => response.json())
        .then(data => {
            if (data.id) {
                // Store the new job ID in localStorage to highlight after reload
                localStorage.setItem('newJobId', data.id);
                sessionStorage.setItem('kanbanScrollX', kanbanBoard.scrollLeft);
                sessionStorage.setItem('kanbanScrollY', kanbanBoard.scrollTop);
                window.location.reload(); // Reload to show new job
            } else if (data.status === 'error') {
                alert('Error creating job: ' + data.message);
            } else {
                alert('Error creating job');
            }
        })
        .catch(error => {
            alert('Error creating job: ' + error);
        });
    });

    // Collect all jobs on page load
    allJobs = Array.from(document.querySelectorAll('.kanban-card')).map(card => parseInt(card.dataset.jobId));

    // Check for newly created job and apply highlight animation
    const newJobId = localStorage.getItem('newJobId');
    if (newJobId) {
        const newJobCard = document.querySelector(`.kanban-card[data-job-id="${newJobId}"]`);
        if (newJobCard) {
            newJobCard.classList.add('new-job-highlight');
            // Scroll the card into view
            newJobCard.scrollIntoView({ behavior: 'smooth', block: 'center' });
            // Remove the animation class after it completes and remove from localStorage
            setTimeout(() => {
                newJobCard.classList.remove('new-job-highlight');
                localStorage.removeItem('newJobId');
            }, 1000);
        } else {
            localStorage.removeItem('newJobId');
        }
    }

    // Check if job ID is in URL query parameters and auto-open
    const urlParams = new URLSearchParams(window.location.search);
    const jobIdFromUrl = urlParams.get('job');
    if (jobIdFromUrl) {
        const jobId = parseInt(jobIdFromUrl);
        if (allJobs.includes(jobId)) {
            currentJobId = jobId;
            currentJobIndex = allJobs.indexOf(jobId);
            loadJobDetails(jobId);
            // Remove the query parameter from URL without reloading
            window.history.replaceState({}, document.title, '/kanban');
        }
    }

    // Kanban Card Event Listeners
    function addCardEventListeners(card) {
        card.addEventListener('dblclick', () => {
            const jobId = card.dataset.jobId;
            currentJobId = jobId;
            currentJobIndex = allJobs.indexOf(parseInt(jobId));
            loadJobDetails(jobId);
        });

        card.addEventListener('dragstart', () => {
            card.classList.add('dragging');
        });

        card.addEventListener('dragend', () => {
            card.classList.remove('dragging');
        });
    }

    // Load Job Details
    function loadJobDetails(jobId) {
        // Set the current job ID
        currentJobId = jobId;

        fetch(`/job/${jobId}/details`)
            .then(response => response.json())
            .then(data => {
                document.getElementById('modal-job-title').textContent = data.title;
                document.getElementById('modal-job-company').textContent = data.company || 'N/A';
                document.getElementById('modal-job-location').textContent = data.location || 'N/A';
                document.getElementById('modal-job-status').innerHTML = `<span class="status-badge status-${data.status.toLowerCase().replace(' ', '-')}">${data.status}</span>`;
                document.getElementById('modal-apply-button').href = data.application_link;

                // Render description as markdown
                const descriptionHtml = renderMarkdown(data.description || 'No description available');
                document.getElementById('modal-job-description').innerHTML = descriptionHtml;

                document.getElementById('modal-job-notes').value = data.notes || '';

                // Show/hide interview section based on status
                const interviewSection = document.getElementById('interview-section');
                if (data.status === 'Interviewing') {
                    interviewSection.style.display = 'block';
                    // Store current job's interview step
                    currentJobStep = data.interview_step || 1;
                    // Render interview chain based on interview_step
                    try {
                        renderInterviewChain(currentJobStep, data.interview_chain);
                    } catch (error) {
                        console.error('Error rendering interview chain:', error);
                    }
                } else {
                    interviewSection.style.display = 'none';
                    currentJobStep = null;
                }

                // Reset notes to edit mode
                notesPreviewMode = false;
                notesTextarea.style.display = 'block';
                notesPreview.style.display = 'none';
                togglePreviewBtn.textContent = 'Preview';

                // Auto-resize notes textarea after loading content
                autoResizeTextarea(document.getElementById('modal-job-notes'));

                // Format and display timestamps
                const scrapedDate = new Date(data.scraped_at);
                const updatedDate = new Date(data.updated_at);
                document.getElementById('modal-job-scraped').textContent = scrapedDate.toLocaleDateString('en-US', {month: 'short', day: 'numeric', year: 'numeric', hour: '2-digit', minute: '2-digit'});
                document.getElementById('modal-job-updated').textContent = updatedDate.toLocaleDateString('en-US', {month: 'short', day: 'numeric', year: 'numeric', hour: '2-digit', minute: '2-digit'});

                // Render contacts
                const contactList = document.getElementById('contact-list');
                contactList.innerHTML = '';
                if (data.contacts && data.contacts.length > 0) {
                    data.contacts.forEach(contact => {
                        const item = document.createElement('div');
                        item.className = 'contact-item';
                        item.innerHTML = `
                            <div class="contact-item-content">
                                <strong>${contact.name}:</strong> <span>${contact.value}</span>
                            </div>
                            <button class="delete-contact" data-contact-id="${contact.id}">√ó</button>
                        `;
                        contactList.appendChild(item);
                    });
                } else {
                    contactList.innerHTML = '<p style="color: var(--text-secondary); font-size: 0.8rem; margin: 0;">No contacts</p>';
                }

                // Render dates
                const datesList = document.getElementById('dates-list');
                datesList.innerHTML = '';
                if (data.dates && data.dates.length > 0) {
                    data.dates.forEach(date => {
                        const item = document.createElement('div');
                        item.className = 'date-item';
                        const dateObj = new Date(date.date);
                        item.innerHTML = `
                            <div class="date-item-content">
                                <strong>${date.category}:</strong> <span>${dateObj.toLocaleString('en-US', {month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit'})}</span>
                            </div>
                            <button class="delete-date" data-date-id="${date.id}">√ó</button>
                        `;
                        datesList.appendChild(item);
                    });
                } else {
                    datesList.innerHTML = '<p style="color: var(--text-secondary); font-size: 0.8rem; margin: 0;">No dates</p>';
                }

                // Update navigation buttons
                document.getElementById('prev-job-button').disabled = currentJobIndex <= 0;
                document.getElementById('next-job-button').disabled = currentJobIndex >= allJobs.length - 1;

                // Update position indicator
                document.getElementById('modal-job-position').textContent = `Job ${currentJobIndex + 1} of ${allJobs.length}`;

                // Scroll modal to top
                const modalBody = document.querySelector('.modal-body-wrapper');
                if (modalBody) {
                    modalBody.scrollTop = 0;
                }

                detailsModal.style.display = 'block';
            });
    }

    // Function to auto-resize textarea
    function autoResizeTextarea(textarea) {
        textarea.style.height = 'auto';
        const newHeight = Math.min(textarea.scrollHeight, 300);
        textarea.style.height = newHeight + 'px';
    }

    // Save interview info button - REMOVED (now using interview chain)

    // Auto-save notes with debouncing and auto-resize
    const notesTextarea = document.getElementById('modal-job-notes');
    const saveStatus = document.getElementById('notes-save-status');
    const notesPreview = document.getElementById('modal-job-notes-preview');
    const togglePreviewBtn = document.getElementById('toggle-notes-preview');
    let notesPreviewMode = false;

    // Toggle between edit and preview mode for notes
    togglePreviewBtn.addEventListener('click', () => {
        notesPreviewMode = !notesPreviewMode;
        if (notesPreviewMode) {
            // Show preview
            const notesMarkdown = notesTextarea.value || 'No notes';
            notesPreview.innerHTML = renderMarkdown(notesMarkdown);
            notesTextarea.style.display = 'none';
            notesPreview.style.display = 'block';
            togglePreviewBtn.textContent = 'Edit';
        } else {
            // Show editor
            notesTextarea.style.display = 'block';
            notesPreview.style.display = 'none';
            togglePreviewBtn.textContent = 'Preview';
        }
    });

    notesTextarea.addEventListener('input', () => {
        // Auto-resize the textarea
        autoResizeTextarea(notesTextarea);

        // Show "saving..." indicator
        saveStatus.textContent = 'saving...';
        saveStatus.style.color = '#f59e0b';

        if (notesAutoSaveTimeout) {
            clearTimeout(notesAutoSaveTimeout);
        }

        notesAutoSaveTimeout = setTimeout(() => {
            // Only save if we have a current job ID
            if (!currentJobId) {
                console.warn('No job ID set, skipping auto-save');
                saveStatus.textContent = 'no job selected';
                saveStatus.style.color = '#ef4444';
                return;
            }

            const notes = notesTextarea.value;

            fetch(`/job/${currentJobId}/details`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ notes: notes })
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.json();
            })
            .then(result => {
                if (result.status === 'success') {
                    // Show success indicator
                    saveStatus.textContent = '‚úì saved';
                    saveStatus.style.color = '#10b981';
                    setTimeout(() => {
                        saveStatus.textContent = '';
                    }, 2000);
                } else {
                    console.error('Error saving notes:', result.message);
                    saveStatus.textContent = 'error saving';
                    saveStatus.style.color = '#ef4444';
                }
            })
            .catch(error => {
                console.error('Error auto-saving notes:', error);
                saveStatus.textContent = 'error: ' + error.message;
                saveStatus.style.color = '#ef4444';
            });
        }, 1000); // Auto-save 1 second after user stops typing
    });

    // Delete Job
    document.getElementById('delete-job-button').addEventListener('click', () => {
        if (confirm('Are you sure you want to delete this job?')) {
            fetch(`/job/${currentJobId}`, { method: 'DELETE' })
                .then(response => response.json())
                .then(result => {
                    if (result.status === 'success') {
                        sessionStorage.setItem('kanbanScrollX', kanbanBoard.scrollLeft);
                        sessionStorage.setItem('kanbanScrollY', kanbanBoard.scrollTop);
                        location.reload();
                    } else {
                        alert('Error deleting job');
                    }
                });
        }
    });

    // Toggle contact form
    document.getElementById('show-contact-form-button').addEventListener('click', () => {
        const form = document.getElementById('contact-form');
        if (form.style.display === 'none' || form.style.display === '') {
            form.style.display = 'grid';
        } else {
            form.style.display = 'none';
        }
    });

    // Add Contact
    document.getElementById('add-contact-button').addEventListener('click', () => {
        const name = document.getElementById('new-contact-name').value;
        const value = document.getElementById('new-contact-value').value;

        if (!name || !value) {
            alert('Please fill in name and contact value');
            return;
        }

        // Auto-detect type based on value
        let type = 'other';
        if (value.includes('@')) {
            type = 'email';
        } else if (value.includes('linkedin.com')) {
            type = 'linkedin';
        } else if (/^\+?[\d\s\-()]+$/.test(value)) {
            type = 'phone';
        }

        fetch(`/job/${currentJobId}/contact`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ name, type, value })
        })
        .then(response => response.json())
        .then(result => {
            if (result.status === 'success') {
                document.getElementById('new-contact-name').value = '';
                document.getElementById('new-contact-value').value = '';
                document.getElementById('contact-form').style.display = 'none';
                loadJobDetails(currentJobId);
            } else {
                alert('Error adding contact');
            }
        });
    });

    // Delete Contact
    document.getElementById('contact-list').addEventListener('click', (e) => {
        if (e.target.classList.contains('delete-contact')) {
            const contactId = e.target.dataset.contactId;
            fetch(`/contact/${contactId}`, { method: 'DELETE' })
                .then(response => response.json())
                .then(result => {
                    if (result.status === 'success') {
                        loadJobDetails(currentJobId);
                    } else {
                        alert('Error deleting contact');
                    }
                });
        }
    });

    // Toggle date form
    document.getElementById('show-date-form-button').addEventListener('click', () => {
        const form = document.getElementById('date-form');
        if (form.style.display === 'none' || form.style.display === '') {
            form.style.display = 'grid';
        } else {
            form.style.display = 'none';
        }
    });

    // Add Date
    document.getElementById('add-date-button').addEventListener('click', () => {
        const category = document.getElementById('new-date-category').value;
        const date = document.getElementById('new-date-input').value;

        if (!date) {
            alert('Please select a date');
            return;
        }

        fetch(`/job/${currentJobId}/date`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                date,
                category,
                title: category,
                description: ''
            })
        })
        .then(response => response.json())
        .then(result => {
            if (result.status === 'success') {
                document.getElementById('new-date-input').value = '';
                document.getElementById('date-form').style.display = 'none';
                loadJobDetails(currentJobId);
            } else {
                alert('Error adding date');
            }
        });
    });

    // Delete Date
    document.getElementById('dates-list').addEventListener('click', (e) => {
        if (e.target.classList.contains('delete-date')) {
            const dateId = e.target.dataset.dateId;
            fetch(`/job_date/${dateId}`, { method: 'DELETE' })
                .then(response => response.json())
                .then(result => {
                    if (result.status === 'success') {
                        loadJobDetails(currentJobId);
                    } else {
                        alert('Error deleting date');
                    }
                });
        }
    });

    // Navigate to previous/next job
    function navigateJob(direction) {
        if (allJobs.length === 0) return;

        currentJobIndex += direction;
        if (currentJobIndex < 0) currentJobIndex = 0;
        if (currentJobIndex >= allJobs.length) currentJobIndex = allJobs.length - 1;

        currentJobId = allJobs[currentJobIndex];
        loadJobDetails(currentJobId);
    }

    // Navigation button handlers
    document.getElementById('prev-job-button').addEventListener('click', () => navigateJob(-1));
    document.getElementById('next-job-button').addEventListener('click', () => navigateJob(1));

    // Keyboard navigation
    document.addEventListener('keydown', (e) => {
        // Only handle keyboard shortcuts when modal is open
        if (detailsModal.style.display !== 'block') return;

        // Don't interfere with typing in inputs, textareas, or selects
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.tagName === 'SELECT') return;

        switch(e.key) {
            case 'ArrowLeft':
                e.preventDefault();
                if (currentJobIndex > 0) {
                    navigateJob(-1);
                }
                break;
            case 'ArrowRight':
                e.preventDefault();
                if (currentJobIndex < allJobs.length - 1) {
                    navigateJob(1);
                }
                break;
            case 'ArrowUp':
                e.preventDefault();
                // Scroll up in modal
                const modalBody = document.querySelector('.modal-body-wrapper');
                modalBody.scrollBy({ top: -100, behavior: 'smooth' });
                break;
            case 'ArrowDown':
                e.preventDefault();
                // Scroll down in modal
                const modalBodyDown = document.querySelector('.modal-body-wrapper');
                modalBodyDown.scrollBy({ top: 100, behavior: 'smooth' });
                break;
            case ' ':
                e.preventDefault();
                // Click the apply button
                document.getElementById('modal-apply-button').click();
                break;
            case 'Delete':
                e.preventDefault();
                // Delete job
                document.getElementById('delete-job-button').click();
                break;
            case 'Escape':
                e.preventDefault();
                detailsModal.style.display = 'none';
                break;
        }
    });

    // Function to reset the add job form
    function resetAddJobForm() {
        addJobForm.reset();
        document.getElementById('linkedin-url').value = '';
        document.getElementById('extract-status').textContent = '';
    }

    // Cancel button for add job modal
    document.getElementById('cancel-add-job-button').addEventListener('click', () => {
        addJobModal.style.display = 'none';
        resetAddJobForm();
    });

    // Close Modals
    document.querySelectorAll('.close-button').forEach(btn => {
        btn.addEventListener('click', () => {
            detailsModal.style.display = 'none';
            if (addJobModal.style.display === 'block') {
                addJobModal.style.display = 'none';
                resetAddJobForm();
            }
        });
    });

    document.getElementById('close-modal-button').addEventListener('click', () => {
        detailsModal.style.display = 'none';
    });

    window.addEventListener('click', (e) => {
        if (e.target === detailsModal) detailsModal.style.display = 'none';
        if (e.target === addJobModal) {
            addJobModal.style.display = 'none';
            resetAddJobForm();
        }
    });

    // Center interview steps if only one step
    const interviewingSteps = document.querySelector('.interviewing-steps');
    if (interviewingSteps) {
        const stepCount = interviewingSteps.querySelectorAll('.interview-step-column').length;
        if (stepCount === 1) {
            interviewingSteps.classList.add('single-step');
        }
    }

    // Drag and Drop
    document.querySelectorAll('.kanban-card').forEach(addCardEventListeners);

    // Handle regular status columns
    document.querySelectorAll('.kanban-column:not(.kanban-interviewing-wrapper)').forEach(column => {
        column.addEventListener('dragover', e => {
            e.preventDefault();
            const afterElement = getDragAfterElement(column, e.clientY);
            const dragging = document.querySelector('.dragging');
            const cardsContainer = column.querySelector('.kanban-cards');

            if (afterElement == null) {
                cardsContainer.appendChild(dragging);
            } else {
                cardsContainer.insertBefore(dragging, afterElement);
            }
        });

        column.addEventListener('drop', e => {
            e.preventDefault();
            const dragging = document.querySelector('.dragging');
            const newStatus = column.dataset.status;
            const jobId = dragging.dataset.jobId;
            const oldInterviewStep = dragging.dataset.interviewStep;

            if (!jobId) {
                console.error('No job ID found');
                return;
            }

            fetch(`/job/${jobId}/status`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ status: newStatus })
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    // If moving from Interviewing to another status, reload to update columns
                    if (oldInterviewStep) {
                        sessionStorage.setItem('kanbanScrollX', kanbanBoard.scrollLeft);
                        sessionStorage.setItem('kanbanScrollY', kanbanBoard.scrollTop);
                        location.reload();
                    } else {
                        console.log('Job status updated successfully');
                    }
                } else {
                    console.error('Failed to update job status:', data);
                }
            })
            .catch(error => {
                console.error('Error updating status:', error);
            });
        });
    });

    // Handle interview step columns
    document.querySelectorAll('.interview-step-column').forEach(stepColumn => {
        const cardsContainer = stepColumn.querySelector('.kanban-cards');

        stepColumn.addEventListener('dragover', e => {
            e.preventDefault();
            const afterElement = getDragAfterElement(stepColumn, e.clientY);
            const dragging = document.querySelector('.dragging');

            if (!dragging || !cardsContainer) return;

            if (afterElement == null) {
                cardsContainer.appendChild(dragging);
            } else {
                cardsContainer.insertBefore(dragging, afterElement);
            }
        });

        stepColumn.addEventListener('drop', e => {
            e.preventDefault();
            const dragging = document.querySelector('.dragging');

            if (!dragging) {
                console.error('No dragging element found');
                return;
            }

            const jobId = dragging.dataset.jobId;
            const interviewStep = stepColumn.dataset.interviewStep;

            if (!jobId || !interviewStep) {
                console.error('Missing jobId or interviewStep');
                return;
            }

            // Update job to this step
            updateInterviewStep(jobId, interviewStep);
        });
    });

    // Add step button
    const addStepButton = document.getElementById('add-interview-step-button');
    if (addStepButton) {
        addStepButton.addEventListener('click', () => {
            // Find the highest step number and add 1
            const existingSteps = Array.from(document.querySelectorAll('.interview-step-column'))
                .map(col => parseInt(col.dataset.interviewStep))
                .filter(step => !isNaN(step));
            const newStep = existingSteps.length > 0 ? Math.max(...existingSteps) + 1 : 1;

            // Create new step column
            const newColumn = document.createElement('div');
            newColumn.className = 'interview-step-column';
            newColumn.setAttribute('data-interview-step', newStep);
            newColumn.innerHTML = `
                <div class="interview-step-header">
                    <h3>Step ${newStep}</h3>
                </div>
                <div class="kanban-cards"></div>
            `;

            // Add event listeners to new column
            const newCardsContainer = newColumn.querySelector('.kanban-cards');

            newColumn.addEventListener('dragover', e => {
                e.preventDefault();
                const afterElement = getDragAfterElement(newColumn, e.clientY);
                const dragging = document.querySelector('.dragging');

                if (!dragging || !newCardsContainer) return;

                if (afterElement == null) {
                    newCardsContainer.appendChild(dragging);
                } else {
                    newCardsContainer.insertBefore(dragging, afterElement);
                }
            });

            newColumn.addEventListener('drop', e => {
                e.preventDefault();
                const dragging = document.querySelector('.dragging');

                if (!dragging) {
                    console.error('No dragging element found');
                    return;
                }

                const jobId = dragging.dataset.jobId;
                if (!jobId) {
                    console.error('Missing jobId');
                    return;
                }

                updateInterviewStep(jobId, newStep);
            });

            // Append to interviewing steps container
            const stepsContainer = document.querySelector('.interviewing-steps');
            stepsContainer.appendChild(newColumn);

            // Remove single-step centering if more than one step now
            if (stepsContainer.querySelectorAll('.interview-step-column').length > 1) {
                stepsContainer.classList.remove('single-step');
            }
        });
    }

    // Handle drop zones for creating new interview steps
    document.querySelectorAll('.interview-drop-zone').forEach(dropZone => {
        dropZone.addEventListener('dragover', e => {
            e.preventDefault();
            dropZone.classList.add('drag-over');
        });

        dropZone.addEventListener('dragleave', e => {
            dropZone.classList.remove('drag-over');
        });

        dropZone.addEventListener('drop', e => {
            e.preventDefault();
            dropZone.classList.remove('drag-over');

            const dragging = document.querySelector('.dragging');
            if (!dragging) return;

            const jobId = dragging.dataset.jobId;
            if (!jobId) return;

            const action = dropZone.dataset.dropAction;
            let targetStep;

            if (action === 'first') {
                // No steps exist yet, create step 1
                targetStep = 1;
            } else if (action === 'before') {
                // Create a step before the current first step
                const step = parseInt(dropZone.dataset.step);
                targetStep = step - 1;

                if (targetStep < 1) {
                    alert('Cannot create a step before Step 1');
                    return;
                }
            } else if (action === 'between') {
                // Create a step between two existing steps based on direction
                const leftStep = parseInt(dropZone.dataset.leftStep);
                const rightStep = parseInt(dropZone.dataset.rightStep);
                const currentStep = parseInt(dragging.dataset.interviewStep) || 0;

                // Determine target step based on which direction the card is moving from
                if (currentStep <= leftStep) {
                    // Moving from left side or from outside, go to leftStep + 1
                    targetStep = leftStep + 1;
                } else {
                    // Moving from right side, go to rightStep - 1
                    targetStep = rightStep - 1;
                }
            } else if (action === 'after') {
                // Create a step after the current last step
                const step = parseInt(dropZone.dataset.step);
                targetStep = step + 1;
            }

            // Update the job to the target step
            updateInterviewStep(jobId, targetStep);
        });
    });

    function updateInterviewStep(jobId, step) {
        // Also set status to Interviewing if not already
        fetch(`/job/${jobId}/status`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ status: 'Interviewing' })
        })
        .then(response => {
            return response.json();
        })
        .then(statusData => {
            return fetch(`/job/${jobId}/interview_step`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ interview_step: step })
            });
        })
        .then(response => {
            return response.json();
        })
        .then(data => {
            if (data.status === 'success') {
                // Save scroll position before reload (needed to update interview columns)
                sessionStorage.setItem('kanbanScrollX', kanbanBoard.scrollLeft);
                sessionStorage.setItem('kanbanScrollY', kanbanBoard.scrollTop);
                location.reload();
            } else {
                console.error('Failed to update interview step:', data);
            }
        })
        .catch(error => {
            console.error('Error in updateInterviewStep:', error);
        });
    }

    function getDragAfterElement(column, y) {
        const draggableElements = [...column.querySelectorAll('.kanban-card:not(.dragging)')];

        return draggableElements.reduce((closest, child) => {
            const box = child.getBoundingClientRect();
            const offset = y - box.top - box.height / 2;
            if (offset < 0 && offset > closest.offset) {
                return { offset: offset, element: child };
            } else {
                return closest;
            }
        }, { offset: Number.NEGATIVE_INFINITY }).element;
    }

    // Search functionality
    const searchInput = document.getElementById('job-search');
    if (searchInput) {
        searchInput.addEventListener('input', (e) => {
            const searchTerm = e.target.value.toLowerCase().trim();
            const allCards = document.querySelectorAll('.kanban-card');

            allCards.forEach(card => {
                const title = card.querySelector('h3').textContent.toLowerCase();
                const company = card.querySelector('p').textContent.toLowerCase();

                // Search in both title and company
                const matchesSearch = title.includes(searchTerm) || company.includes(searchTerm);

                if (matchesSearch || searchTerm === '') {
                    card.classList.remove('hidden-by-search');
                } else {
                    card.classList.add('hidden-by-search');
                }
            });
        });
    }

    // ============================================================================
    // INTERVIEW CHAIN FUNCTIONALITY
    // ============================================================================

    let interviewChainData = [];

    function renderInterviewChain(totalSteps, chainDataJSON) {
        const container = document.getElementById('interview-chain-container');

        // Parse chain data if it exists
        try {
            interviewChainData = chainDataJSON ? JSON.parse(chainDataJSON) : [];
        } catch (e) {
            interviewChainData = [];
        }

        // Ensure we have data for all steps
        while (interviewChainData.length < totalSteps) {
            interviewChainData.push({
                step: interviewChainData.length + 1,
                type: null,
                date: null,
                status: 'pending',
                interviewer: null,
                notes: null
            });
        }

        if (totalSteps === 0) {
            container.innerHTML = `
                <div class="chain-empty-state">
                    <p>No interview steps yet.</p>
                    <p style="font-size: 0.8rem;">Drag interview types from above onto the chain links.</p>
                </div>
            `;
            return;
        }

        let chainHTML = '<div class="interview-chain">';

        for (let i = 0; i < totalSteps; i++) {
            const linkData = interviewChainData[i] || {};
            const isFilled = linkData.type !== null && linkData.type !== undefined;
            const stepNumber = i + 1;

            const isCompleted = linkData.status === 'completed';
            chainHTML += `
                <div class="interview-chain-link">
                    <div class="chain-link-circle ${isFilled ? (isCompleted ? 'completed' : 'filled') : ''}"
                         data-step="${stepNumber}"
                         data-droppable="true">
                        ${isFilled ? (linkData.emoji || stepNumber) : stepNumber}
                        ${linkData.type ? `
                            <div class="chain-link-delete" onclick="removeChainLink(${stepNumber})" title="Remove">√ó</div>
                            <div class="chain-link-complete" onclick="toggleCompleteChainLink(${stepNumber})" title="${isCompleted ? 'Mark incomplete' : 'Mark complete'}">${isCompleted ? '‚úì' : '‚úì'}</div>
                            <div class="chain-link-add-date" onclick="editChainLink(${stepNumber})" title="Set date">üìÖ</div>
                        ` : ''}
                    </div>
                    ${linkData.type ? `
                        <div class="chain-link-details">
                            <div class="chain-link-type">${linkData.type}</div>
                            ${linkData.date ? `<div class="chain-link-date">üìÖ ${formatDate(linkData.date)}</div>` : '<div class="chain-link-date" style="color: #d1d5db;">No date</div>'}
                            ${linkData.interviewer ? `<div style="font-size: 0.7rem; color: var(--text-secondary);">üë§ ${linkData.interviewer}</div>` : ''}
                        </div>
                    ` : ''}
                </div>
            `;

            // Add connector between links (except after the last one)
            if (i < totalSteps - 1) {
                chainHTML += `<div class="chain-link-connector ${isCompleted ? 'completed' : (isFilled ? 'filled' : '')}"></div>`;
            }
        }

        chainHTML += '</div>';
        container.innerHTML = chainHTML;

        // Add drag and drop event listeners to chain links
        setupChainDropZones();
    }

    function setupChainDropZones() {
        document.querySelectorAll('.chain-link-circle[data-droppable="true"]').forEach(circle => {
            circle.addEventListener('dragover', (e) => {
                e.preventDefault();
                circle.classList.add('drag-over');
            });

            circle.addEventListener('dragleave', () => {
                circle.classList.remove('drag-over');
            });

            circle.addEventListener('drop', (e) => {
                e.preventDefault();
                circle.classList.remove('drag-over');

                const interviewType = e.dataTransfer.getData('text/plain');
                const emoji = e.dataTransfer.getData('text/emoji');
                const step = parseInt(circle.dataset.step);

                if (interviewType) {
                    addInterviewTypeToChain(step, interviewType, emoji);
                }
            });
        });
    }

    function addInterviewTypeToChain(step, type, emoji) {
        // Update the chain data
        if (interviewChainData[step - 1]) {
            interviewChainData[step - 1].type = type;
            interviewChainData[step - 1].emoji = emoji || '';
            interviewChainData[step - 1].status = 'scheduled';
        }

        // Save to backend and re-render
        saveInterviewChain();
    }

    function editChainLink(step) {
        const linkData = interviewChainData[step - 1];
        if (!linkData) return;

        // Create a simple date picker modal
        const dateInput = document.createElement('input');
        dateInput.type = 'datetime-local';
        dateInput.value = linkData.date || '';
        dateInput.style.cssText = 'padding: 0.5rem; border: 1px solid var(--border-color); border-radius: 4px; width: 100%; margin-bottom: 0.75rem;';

        const interviewerInput = document.createElement('input');
        interviewerInput.type = 'text';
        interviewerInput.placeholder = 'Interviewer name (optional)';
        interviewerInput.value = linkData.interviewer || '';
        interviewerInput.style.cssText = 'padding: 0.5rem; border: 1px solid var(--border-color); border-radius: 4px; width: 100%;';

        const modalContent = document.createElement('div');
        modalContent.style.cssText = 'background: white; padding: 1.5rem; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); max-width: 350px;';
        modalContent.innerHTML = `<h3 style="margin: 0 0 1rem 0; font-size: 1rem;">Set Interview Details</h3>`;
        modalContent.appendChild(dateInput);
        modalContent.appendChild(interviewerInput);

        const buttonContainer = document.createElement('div');
        buttonContainer.style.cssText = 'display: flex; gap: 0.5rem; margin-top: 1rem; justify-content: flex-end;';

        const saveBtn = document.createElement('button');
        saveBtn.textContent = 'Save';
        saveBtn.className = 'btn';
        saveBtn.style.cssText = 'padding: 0.5rem 1rem; cursor: pointer;';
        saveBtn.onclick = () => {
            linkData.date = dateInput.value;
            linkData.interviewer = interviewerInput.value;

            // Also create/update a calendar date entry
            if (linkData.date && currentJobId) {
                const interviewTitle = linkData.type || `Interview Step ${step}`;
                const interviewerInfo = linkData.interviewer ? ` with ${linkData.interviewer}` : '';

                fetch(`/job/${currentJobId}/interview_date`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        date: linkData.date,
                        title: interviewTitle + interviewerInfo,
                        step: step
                    })
                })
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'success') {
                        console.log('Calendar date synced');
                    }
                })
                .catch(error => {
                    console.error('Error syncing calendar:', error);
                });
            }

            saveInterviewChain();
            overlay.remove();
        };

        const cancelBtn = document.createElement('button');
        cancelBtn.textContent = 'Cancel';
        cancelBtn.className = 'btn-secondary';
        cancelBtn.style.cssText = 'padding: 0.5rem 1rem; cursor: pointer;';
        cancelBtn.onclick = () => overlay.remove();

        buttonContainer.appendChild(cancelBtn);
        buttonContainer.appendChild(saveBtn);
        modalContent.appendChild(buttonContainer);

        const overlay = document.createElement('div');
        overlay.style.cssText = 'position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); display: flex; align-items: center; justify-content: center; z-index: 10000;';
        overlay.onclick = (e) => { if (e.target === overlay) overlay.remove(); };
        overlay.appendChild(modalContent);

        document.body.appendChild(overlay);
        dateInput.focus();
    }

    function removeChainLink(step) {
        if (confirm('Remove this interview type?')) {
            interviewChainData[step - 1] = {
                step: step,
                type: null,
                date: null,
                status: 'pending',
                interviewer: null,
                notes: null
            };
            saveInterviewChain();
        }
    }

    function toggleCompleteChainLink(step) {
        const linkData = interviewChainData[step - 1];
        if (!linkData) return;

        // Toggle between completed and scheduled
        if (linkData.status === 'completed') {
            linkData.status = 'scheduled';
        } else {
            linkData.status = 'completed';
        }

        saveInterviewChain();
    }

    function saveInterviewChain() {
        if (!currentJobId) return;

        // Get the current step's interview type to update interview_stage_name
        let stageName = null;
        if (currentJobStep && interviewChainData[currentJobStep - 1]) {
            stageName = interviewChainData[currentJobStep - 1].type;
        }

        fetch(`/job/${currentJobId}/interview_chain`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                interview_chain: JSON.stringify(interviewChainData),
                interview_stage_name: stageName
            })
        })
        .then(response => response.json())
        .then(data => {
            if (data.status === 'success') {
                // Re-render the chain
                const totalSteps = interviewChainData.length;
                renderInterviewChain(totalSteps, JSON.stringify(interviewChainData));

                // Update the card on the kanban board
                const card = document.querySelector(`.kanban-card[data-job-id="${currentJobId}"]`);
                if (card && stageName) {
                    // Check if stage name already exists
                    let stageP = card.querySelector('p[style*="color: var(--primary-color)"]');
                    if (stageP) {
                        stageP.textContent = stageName;
                    } else {
                        // Create new stage name element after company
                        const companyP = card.querySelector('p[style*="font-weight: 600"]');
                        if (companyP) {
                            stageP = document.createElement('p');
                            stageP.style.cssText = 'font-size: 0.85rem; color: var(--primary-color); margin-top: 0.25rem; font-weight: 500;';
                            stageP.textContent = stageName;
                            companyP.after(stageP);
                        }
                    }
                } else if (card && !stageName) {
                    // Remove stage name if cleared
                    const stageP = card.querySelector('p[style*="color: var(--primary-color)"]');
                    if (stageP) stageP.remove();
                }
            }
        })
        .catch(error => {
            console.error('Error saving interview chain:', error);
        });
    }

    function formatDate(dateStr) {
        if (!dateStr) return '';
        const date = new Date(dateStr);
        return date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit', hour12: false});
    }

    // Setup drag and drop for interview type blocks
    document.querySelectorAll('.interview-type-block').forEach(block => {
        block.addEventListener('dragstart', (e) => {
            e.dataTransfer.setData('text/plain', block.dataset.type);
            // Extract emoji from the block text content
            const emoji = block.textContent.trim().split(' ')[0];
            e.dataTransfer.setData('text/emoji', emoji);
            block.style.opacity = '0.5';
        });

        block.addEventListener('dragend', (e) => {
            block.style.opacity = '1';
        });
    });

    // Add custom interview type
    document.getElementById('add-custom-interview-type')?.addEventListener('click', () => {
        // Create modal for custom interview type
        const nameInput = document.createElement('input');
        nameInput.type = 'text';
        nameInput.placeholder = 'Interview type name (e.g., HR Interview)';
        nameInput.style.cssText = 'padding: 0.5rem; border: 1px solid var(--border-color); border-radius: 4px; width: 100%; margin-bottom: 0.75rem;';

        const emojiInput = document.createElement('input');
        emojiInput.type = 'text';
        emojiInput.placeholder = 'Emoji (e.g., üé§)';
        emojiInput.maxLength = 2;
        emojiInput.style.cssText = 'padding: 0.5rem; border: 1px solid var(--border-color); border-radius: 4px; width: 100%; font-size: 1.5rem; text-align: center;';

        const commonEmojis = document.createElement('div');
        commonEmojis.style.cssText = 'display: flex; gap: 0.5rem; flex-wrap: wrap; justify-content: center; margin-bottom: 0.75rem;';
        const emojis = ['üìã', 'üé§', 'üíº', 'üèÜ', 'üìä', 'üéØ', 'üîç', '‚úÖ', 'üìù', 'üí°', 'üöÄ', '‚≠ê'];
        emojis.forEach(emoji => {
            const btn = document.createElement('button');
            btn.textContent = emoji;
            btn.style.cssText = 'padding: 0.5rem; border: 1px solid var(--border-color); border-radius: 4px; cursor: pointer; font-size: 1.5rem; background: white;';
            btn.onclick = () => emojiInput.value = emoji;
            commonEmojis.appendChild(btn);
        });

        const modalContent = document.createElement('div');
        modalContent.style.cssText = 'background: white; padding: 1.5rem; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); max-width: 400px;';
        modalContent.innerHTML = `<h3 style="margin: 0 0 1rem 0; font-size: 1rem;">Create Custom Interview Type</h3>
            <label style="display: block; font-size: 0.85rem; margin-bottom: 0.25rem; color: var(--text-secondary);">Select or enter emoji:</label>`;
        modalContent.appendChild(commonEmojis);
        modalContent.appendChild(emojiInput);
        const nameLabel = document.createElement('label');
        nameLabel.style.cssText = 'display: block; font-size: 0.85rem; margin: 0.75rem 0 0.25rem 0; color: var(--text-secondary);';
        nameLabel.textContent = 'Interview type name:';
        modalContent.appendChild(nameLabel);
        modalContent.appendChild(nameInput);

        const buttonContainer = document.createElement('div');
        buttonContainer.style.cssText = 'display: flex; gap: 0.5rem; margin-top: 1rem; justify-content: flex-end;';

        const saveBtn = document.createElement('button');
        saveBtn.textContent = 'Create';
        saveBtn.className = 'btn';
        saveBtn.style.cssText = 'padding: 0.5rem 1rem; cursor: pointer;';
        saveBtn.onclick = () => {
            const customType = nameInput.value.trim();
            const emoji = emojiInput.value.trim() || 'üìã';

            if (customType) {
                const palette = document.querySelector('.interview-type-palette');
                const customBlock = document.createElement('div');
                customBlock.className = 'interview-type-block custom';
                customBlock.setAttribute('draggable', 'true');
                customBlock.setAttribute('data-type', customType);
                customBlock.textContent = emoji + ' ' + customType;

                // Add drag listeners
                customBlock.addEventListener('dragstart', (e) => {
                    e.dataTransfer.setData('text/plain', customBlock.dataset.type);
                    const emoji = customBlock.textContent.trim().split(' ')[0];
                    e.dataTransfer.setData('text/emoji', emoji);
                    customBlock.style.opacity = '0.5';
                });

                customBlock.addEventListener('dragend', (e) => {
                    customBlock.style.opacity = '1';
                });

                palette.insertBefore(customBlock, document.getElementById('add-custom-interview-type'));
                overlay.remove();
            }
        };

        const cancelBtn = document.createElement('button');
        cancelBtn.textContent = 'Cancel';
        cancelBtn.className = 'btn-secondary';
        cancelBtn.style.cssText = 'padding: 0.5rem 1rem; cursor: pointer;';
        cancelBtn.onclick = () => overlay.remove();

        buttonContainer.appendChild(cancelBtn);
        buttonContainer.appendChild(saveBtn);
        modalContent.appendChild(buttonContainer);

        const overlay = document.createElement('div');
        overlay.style.cssText = 'position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); display: flex; align-items: center; justify-content: center; z-index: 10000;';
        overlay.onclick = (e) => { if (e.target === overlay) overlay.remove(); };
        overlay.appendChild(modalContent);

        document.body.appendChild(overlay);
        nameInput.focus();
    });

    // Auto-scroll zones functionality
    const kanbanBoard = document.querySelector('.kanban-board');
    const scrollZoneLeft = document.getElementById('scroll-zone-left');
    const scrollZoneRight = document.getElementById('scroll-zone-right');
    const scrollZoneTop = document.getElementById('scroll-zone-top');
    const scrollZoneBottom = document.getElementById('scroll-zone-bottom');

    let autoScrollEnabled = true; // Toggle with spacebar
    let isDragging = false; // Track drag state

    // Restore scroll position after reload
    const savedScrollX = sessionStorage.getItem('kanbanScrollX');
    const savedScrollY = sessionStorage.getItem('kanbanScrollY');
    if (savedScrollX !== null && savedScrollY !== null) {
        kanbanBoard.scrollLeft = parseInt(savedScrollX);
        kanbanBoard.scrollTop = parseInt(savedScrollY);
        // Clear the saved position
        sessionStorage.removeItem('kanbanScrollX');
        sessionStorage.removeItem('kanbanScrollY');
    }

    // Position top/bottom scroll zones over the kanban board
    function positionVerticalScrollZones() {
        const boardRect = kanbanBoard.getBoundingClientRect();
        scrollZoneTop.style.top = boardRect.top + 'px';
        scrollZoneBottom.style.bottom = (window.innerHeight - boardRect.bottom) + 'px';
    }

    positionVerticalScrollZones();
    window.addEventListener('resize', positionVerticalScrollZones);
    window.addEventListener('scroll', positionVerticalScrollZones);

    let scrollAnimationFrame = null;
    let scrollSpeedX = 0;
    let scrollSpeedY = 0;
    const SCROLL_ZONE_WIDTH = 250; // pixels from edge (horizontal)
    const SCROLL_ZONE_HEIGHT = 200; // pixels from edge (vertical)
    const MAX_SCROLL_SPEED = 10; // pixels per frame

    // Spacebar toggle for auto-scroll
    const autoScrollTip = document.getElementById('auto-scroll-tip');
    let tipHideTimeout;

    document.addEventListener('keydown', (e) => {
        if (e.code === 'Space' && !e.target.matches('input, textarea')) {
            e.preventDefault();
            autoScrollEnabled = !autoScrollEnabled;
            if (!autoScrollEnabled) {
                stopAutoScroll();
            }

            // Update tip visual
            if (autoScrollEnabled) {
                autoScrollTip.classList.remove('disabled');
                autoScrollTip.querySelector('span').textContent = 'Auto-scroll enabled';
            } else {
                autoScrollTip.classList.add('disabled');
                autoScrollTip.querySelector('span').textContent = 'Auto-scroll disabled';
            }

            // Show tip when toggling
            clearTimeout(tipHideTimeout);
            autoScrollTip.style.display = 'flex';
            autoScrollTip.style.opacity = '1';

            tipHideTimeout = setTimeout(() => {
                autoScrollTip.style.opacity = '0';
                setTimeout(() => {
                    autoScrollTip.style.display = 'none';
                }, 300);
            }, 3000);
        }
    });

    function startAutoScroll() {
        if (scrollAnimationFrame) return;

        function scroll() {
            if (scrollSpeedX !== 0 || scrollSpeedY !== 0) {
                // Horizontal scrolling on kanban-board
                if (scrollSpeedX !== 0) {
                    kanbanBoard.scrollLeft += scrollSpeedX;
                }
                // Vertical scrolling on kanban-board
                if (scrollSpeedY !== 0) {
                    kanbanBoard.scrollTop += scrollSpeedY;
                }
                scrollAnimationFrame = requestAnimationFrame(scroll);
            } else {
                scrollAnimationFrame = null;
            }
        }

        scrollAnimationFrame = requestAnimationFrame(scroll);
    }

    function stopAutoScroll() {
        if (scrollAnimationFrame) {
            cancelAnimationFrame(scrollAnimationFrame);
            scrollAnimationFrame = null;
        }
        scrollSpeedX = 0;
        scrollSpeedY = 0;
        scrollZoneLeft.classList.remove('active');
        scrollZoneRight.classList.remove('active');
        scrollZoneTop.classList.remove('active');
        scrollZoneBottom.classList.remove('active');
    }

    // Handle both regular mousemove and during drag operations
    function handleAutoScroll(e) {
        // Don't auto-scroll if disabled, temporarily disabled after drop, or modal is open
        if (!autoScrollEnabled || isDragging) {
            stopAutoScroll();
            return;
        }

        // Check if any modal is visible
        const modalVisible = detailsModal.style.display === 'block' ||
                           addJobModal.style.display === 'block' ||
                           document.querySelector('.modal[style*="display: block"]') !== null;

        if (modalVisible) {
            stopAutoScroll();
            return;
        }

        const mouseX = e.clientX;
        const mouseY = e.clientY;
        const windowWidth = window.innerWidth;
        const boardRect = kanbanBoard.getBoundingClientRect();

        let horizontalActive = false;
        let verticalActive = false;

        // Check horizontal scroll zones
        if (mouseX < SCROLL_ZONE_WIDTH) {
            const intensity = 1 - (mouseX / SCROLL_ZONE_WIDTH);
            scrollSpeedX = -MAX_SCROLL_SPEED * intensity;
            scrollZoneLeft.classList.add('active');
            scrollZoneRight.classList.remove('active');
            horizontalActive = true;
        } else if (mouseX > windowWidth - SCROLL_ZONE_WIDTH) {
            const intensity = (mouseX - (windowWidth - SCROLL_ZONE_WIDTH)) / SCROLL_ZONE_WIDTH;
            scrollSpeedX = MAX_SCROLL_SPEED * intensity;
            scrollZoneRight.classList.add('active');
            scrollZoneLeft.classList.remove('active');
            horizontalActive = true;
        } else {
            scrollSpeedX = 0;
            scrollZoneLeft.classList.remove('active');
            scrollZoneRight.classList.remove('active');
        }

        // Check vertical scroll zones (only within kanban board area)
        if (mouseY >= boardRect.top && mouseY <= boardRect.bottom) {
            const relativeY = mouseY - boardRect.top;
            const boardHeight = boardRect.height;

            if (relativeY < SCROLL_ZONE_HEIGHT) {
                const intensity = 1 - (relativeY / SCROLL_ZONE_HEIGHT);
                scrollSpeedY = -MAX_SCROLL_SPEED * intensity;
                scrollZoneTop.classList.add('active');
                scrollZoneBottom.classList.remove('active');
                verticalActive = true;
            } else if (relativeY > boardHeight - SCROLL_ZONE_HEIGHT) {
                const intensity = (relativeY - (boardHeight - SCROLL_ZONE_HEIGHT)) / SCROLL_ZONE_HEIGHT;
                scrollSpeedY = MAX_SCROLL_SPEED * intensity;
                scrollZoneBottom.classList.add('active');
                scrollZoneTop.classList.remove('active');
                verticalActive = true;
            } else {
                scrollSpeedY = 0;
                scrollZoneTop.classList.remove('active');
                scrollZoneBottom.classList.remove('active');
            }
        } else {
            scrollSpeedY = 0;
            scrollZoneTop.classList.remove('active');
            scrollZoneBottom.classList.remove('active');
        }

        // Start or stop scrolling based on whether we're in any zone
        if (horizontalActive || verticalActive) {
            startAutoScroll();
        } else if (!horizontalActive && !verticalActive) {
            stopAutoScroll();
        }
    }

    document.addEventListener('mousemove', handleAutoScroll);
    document.addEventListener('dragover', handleAutoScroll);

    // Stop auto-scroll when drag ends or drop happens to prevent camera jump
    let scrollStopTimeout;

    document.addEventListener('dragstart', (e) => {
        // Allow scrolling during drag - don't set isDragging here
        isDragging = false;
    });

    document.addEventListener('dragend', (e) => {
        // Stop scrolling immediately and prevent any new scroll animations
        stopAutoScroll();
        isDragging = true; // Temporarily disable auto-scroll to prevent jump

        // Re-enable after a short delay
        clearTimeout(scrollStopTimeout);
        scrollStopTimeout = setTimeout(() => {
            isDragging = false;
        }, 150);
    });

    document.addEventListener('drop', (e) => {
        // Stop scrolling on drop as well and disable briefly
        stopAutoScroll();
        isDragging = true;

        clearTimeout(scrollStopTimeout);
        scrollStopTimeout = setTimeout(() => {
            isDragging = false;
        }, 150);
    });

    // Stop scrolling when mouse leaves the window
    document.addEventListener('mouseleave', stopAutoScroll);

    // Hide auto-scroll tip after 5 seconds
    setTimeout(() => {
        autoScrollTip.style.opacity = '0';
        setTimeout(() => {
            autoScrollTip.style.display = 'none';
        }, 300);
    }, 5000);

    // Make functions globally accessible for onclick handlers
    window.editChainLink = editChainLink;
    window.removeChainLink = removeChainLink;
    window.toggleCompleteChainLink = toggleCompleteChainLink;
});
</script>
{% endblock %}
